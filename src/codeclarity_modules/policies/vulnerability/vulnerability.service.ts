import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { AuthenticatedUser } from 'src/base_modules/auth/auth.types';
import { MemberRole } from 'src/base_modules/organizations/memberships/orgMembership.types';
import { OrganizationsRepository } from 'src/base_modules/organizations/organizations.repository';
import { UsersRepository } from 'src/base_modules/users/users.repository';
import { Policy, PolicyFrontend } from 'src/codeclarity_modules/policies/policy.entity';
import { PolicyType } from 'src/codeclarity_modules/policies/policy.types';
import {
    VulnerabilityPolicyCreateBody,
    VulnerabilityPolicyPatchBody
} from 'src/codeclarity_modules/policies/vulnerability/vulnerabilityPolicy.types';
import {
    PaginationConfig,
    TypedPaginatedData,
    PaginationUserSuppliedConf
} from 'src/types/pagination.types';
import { SortDirection } from 'src/types/sort.types';
import { Repository } from 'typeorm';

@Injectable()
export class VulnerabilityPolicyService {
    constructor(
        private readonly organizationsRepository: OrganizationsRepository,
        private readonly usersRepository: UsersRepository,
        @InjectRepository(Policy, 'codeclarity')
        private policyRepository: Repository<Policy>
    ) {}

    /**
     * Create a vulnerability policy
     * @param orgId The id of the organization
     * @param create The vulnerability policy data
     * @param user The authenticated user
     * @returns the id of the created vulnerability policy
     */
    async create(
        orgId: string,
        create: VulnerabilityPolicyCreateBody,
        user: AuthenticatedUser
    ): Promise<string> {
        // Only owners and admins can add a policy to the org
        await this.organizationsRepository.hasRequiredRole(orgId, user.userId, MemberRole.ADMIN);

        const organization = await this.organizationsRepository.getOrganizationById(orgId);
        if (!organization) {
            throw new Error('EntityNotFound');
        }

        const creator = await this.usersRepository.getUserById(user.userId);
        if (!creator) {
            throw new Error('EntityNotFound');
        }

        // If this is set as default, remove default from other vulnerability policies
        if (create.default) {
            // Find existing default vulnerability policies for this organization
            const existingDefaultPolicies = await this.policyRepository
                .createQueryBuilder('policy')
                .leftJoin('policy.organizations', 'organization')
                .where('policy.policy_type = :policyType', {
                    policyType: PolicyType.VULNERABILITY_POLICY
                })
                .andWhere('policy.default = :default', { default: true })
                .andWhere('organization.id = :orgId', { orgId })
                .getMany();

            // Update each one to not be default
            for (const policy of existingDefaultPolicies) {
                policy.default = false;
                await this.policyRepository.save(policy);
            }
        }

        const policy = await this.policyRepository.save({
            policy_type: PolicyType.VULNERABILITY_POLICY,
            default: create.default,
            created_on: new Date(),
            created_by: creator,
            name: create.name,
            description: create.description,
            content: create.vulnerabilities,
            organizations: [organization],
            analyses: []
        } as Partial<Policy>);

        return policy.id;
    }

    /**
     * Get a vulnerability policy
     * @param orgId The id of the org
     * @param vulnerabilityPolicyId The id of the vulnerability policy
     * @param user The authenticated user
     * @returns the vulnerability policy
     */
    async get(
        orgId: string,
        vulnerabilityPolicyId: string,
        user: AuthenticatedUser
    ): Promise<Policy> {
        // Check if user has access to org
        await this.organizationsRepository.hasRequiredRole(orgId, user.userId, MemberRole.USER);

        const policy = await this.policyRepository.findOne({
            where: {
                id: vulnerabilityPolicyId,
                policy_type: PolicyType.VULNERABILITY_POLICY,
                organizations: { id: orgId } as { id: string }
            },
            relations: ['created_by']
        });

        if (!policy) {
            throw new Error('EntityNotFound');
        }

        return policy;
    }

    /**
     * Get the vulnerability policies belonging to the org
     * @param orgId The id of the org
     * @param paginationUserSuppliedConf Pagination configuration
     * @param user The authenticated user
     * @param searchKey A search key to filter the records by
     * @param sortBy A sort field to sort the records by
     * @param sortDirection A sort direction
     * @returns the vulnerability policies belonging to the org
     */
    async getMany(
        orgId: string,
        paginationUserSuppliedConf: PaginationUserSuppliedConf,
        user: AuthenticatedUser,
        searchKey?: string,
        sortBy?: string,
        sortDirection?: SortDirection
    ): Promise<TypedPaginatedData<PolicyFrontend>> {
        // Check if user has access to org
        await this.organizationsRepository.hasRequiredRole(orgId, user.userId, MemberRole.USER);

        const paginationConfig: PaginationConfig = {
            maxEntriesPerPage: 100,
            defaultEntriesPerPage: 10
        };

        let entriesPerPage = paginationConfig.defaultEntriesPerPage;
        let currentPage = 0;

        if (paginationUserSuppliedConf.entriesPerPage)
            entriesPerPage = Math.min(
                paginationConfig.maxEntriesPerPage,
                paginationUserSuppliedConf.entriesPerPage
            );

        if (paginationUserSuppliedConf.currentPage)
            currentPage = Math.max(0, paginationUserSuppliedConf.currentPage);

        const queryBuilder = this.policyRepository
            .createQueryBuilder('policy')
            .leftJoin('policy.organizations', 'organization')
            .leftJoin('policy.created_by', 'creator')
            .where('organization.id = :orgId', { orgId })
            .andWhere('policy.policy_type = :policyType', {
                policyType: PolicyType.VULNERABILITY_POLICY
            });

        // Apply search filter
        if (searchKey?.trim()) {
            queryBuilder.andWhere(
                '(policy.name ILIKE :searchKey OR policy.description ILIKE :searchKey)',
                { searchKey: `%${searchKey.trim()}%` }
            );
        }

        // Apply sorting
        if (sortBy && ['name', 'created_on', 'description'].includes(sortBy)) {
            const direction = sortDirection === SortDirection.ASC ? 'ASC' : 'DESC';
            queryBuilder.orderBy(`policy.${sortBy}`, direction);
        } else {
            queryBuilder.orderBy('policy.created_on', 'DESC');
        }

        const fullCount = await queryBuilder.getCount();

        const policies = await queryBuilder
            .skip(currentPage * entriesPerPage)
            .take(entriesPerPage)
            .getMany();

        const res: PolicyFrontend[] = policies.map((policy) => ({
            id: policy.id,
            name: policy.name,
            description: policy.description,
            default: policy.default,
            content: policy.content,
            created_on: policy.created_on,
            created_by: policy.created_by?.email || '',
            policy_type: policy.policy_type
        }));

        return {
            data: res,
            page: currentPage,
            entry_count: policies.length,
            entries_per_page: entriesPerPage,
            total_entries: fullCount,
            total_pages: Math.ceil(fullCount / entriesPerPage),
            matching_count: fullCount,
            filter_count: {}
        };
    }

    /**
     * Update an existing vulnerability policy
     * @throws {EntityNotFound} if the vulnerability policy does not exist
     *
     * @param orgId The id of the organization to which the vulnerability policy belongs
     * @param vulnerabilityPolicyId The id of the vulnerability policy
     * @param update The update
     * @param user The authenticated user
     */
    async update(
        orgId: string,
        vulnerabilityPolicyId: string,
        update: VulnerabilityPolicyPatchBody,
        user: AuthenticatedUser
    ): Promise<void> {
        // Only owners and admins can update a policy in the org
        await this.organizationsRepository.hasRequiredRole(orgId, user.userId, MemberRole.ADMIN);

        const policy = await this.policyRepository.findOne({
            where: {
                id: vulnerabilityPolicyId,
                policy_type: PolicyType.VULNERABILITY_POLICY,
                organizations: { id: orgId } as { id: string }
            }
        });

        if (!policy) {
            throw new Error('EntityNotFound');
        }

        // If this is being set as default, remove default from other vulnerability policies
        if (update.default === true) {
            await this.policyRepository.update(
                {
                    policy_type: PolicyType.VULNERABILITY_POLICY,
                    organizations: { id: orgId } as { id: string },
                    default: true
                },
                { default: false }
            );
        }

        // Update the policy
        const updateData: Partial<Policy> = {};

        if (update.name !== undefined) updateData.name = update.name;
        if (update.description !== undefined) updateData.description = update.description;
        if (update.vulnerabilities !== undefined) updateData.content = update.vulnerabilities;
        if (update.default !== undefined) updateData.default = update.default;

        await this.policyRepository.update(
            vulnerabilityPolicyId,
            updateData as Record<string, unknown>
        );
    }

    /**
     * Remove an existing vulnerability policy
     * @throws {EntityNotFound} if the vulnerability policy does not exist
     *
     * @param orgId The id of the organization to which the policy belongs
     * @param vulnerabilityPolicyId The id of the vulnerability policy
     * @param user The authenticated user
     */
    async remove(
        orgId: string,
        vulnerabilityPolicyId: string,
        user: AuthenticatedUser
    ): Promise<void> {
        // Only owners and admins can remove a policy from the org
        await this.organizationsRepository.hasRequiredRole(orgId, user.userId, MemberRole.ADMIN);

        const policy = await this.policyRepository.findOne({
            where: {
                id: vulnerabilityPolicyId,
                policy_type: PolicyType.VULNERABILITY_POLICY,
                organizations: { id: orgId } as { id: string }
            }
        });

        if (!policy) {
            throw new Error('EntityNotFound');
        }

        await this.policyRepository.remove(policy);
    }

    /**
     * Get the default vulnerability policy for an organization
     * @param orgId The id of the organization
     * @returns the default vulnerability policy or null if none exists
     */
    async getDefaultPolicy(orgId: string): Promise<Policy | null> {
        const policy = await this.policyRepository.findOne({
            where: {
                policy_type: PolicyType.VULNERABILITY_POLICY,
                organizations: { id: orgId } as { id: string },
                default: true
            }
        });

        return policy ?? null;
    }
}
