import { Injectable } from '@nestjs/common';
import { AnalysisResultsService } from '../results.service';
import { AuthenticatedUser } from 'src/base_modules/auth/auth.types';
import { OSVRepository } from 'src/codeclarity_modules/knowledge/osv/osv.repository';
import { NVDRepository } from 'src/codeclarity_modules/knowledge/nvd/nvd.repository';
import { FriendsOfPhpRepository } from 'src/codeclarity_modules/knowledge/friendsofphp/friendsofphp.repository';
import { NVDReportGenerator, OSVReportGenerator } from './services/reportGenerator';
import { EntityNotFound, UnknownWorkspace } from 'src/types/error.types';
import { VulnerabilityDetails } from 'src/codeclarity_modules/results/vulnerabilities/vulnerabilities2.types';
import { Vulnerability } from 'src/codeclarity_modules/results/vulnerabilities/vulnerabilities.types';
import { Output as VulnsOutput } from 'src/codeclarity_modules/results/vulnerabilities/vulnerabilities.types';
import { PatchInfo } from 'src/codeclarity_modules/results/patching/patching.types';
import { Dependency } from 'src/codeclarity_modules/results/sbom/sbom.types';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { Result } from 'src/codeclarity_modules/results/result.entity';
import { VulnerabilitiesUtilsService } from './utils/utils.service';
import { SbomUtilsService } from '../sbom/utils/utils';
import { PatchingUtilsService } from '../patching/utils/utils';

@Injectable()
export class VulnerabilityService {
    constructor(
        private readonly analysisResultsService: AnalysisResultsService,
        private readonly osvRepository: OSVRepository,
        private readonly nvdRepository: NVDRepository,
        private readonly friendsOfPhpRepository: FriendsOfPhpRepository,
        private readonly osvReportGenerator: OSVReportGenerator,
        private readonly nvdReportGenerator: NVDReportGenerator,
        private readonly vulnerabilitiesUtilsService: VulnerabilitiesUtilsService,
        private readonly patchingUtilsService: PatchingUtilsService,
        private readonly sbomUtilsService: SbomUtilsService,
        @InjectRepository(Result, 'codeclarity')
        private resultRepository: Repository<Result>
    ) {}

    async getVulnerability(
        orgId: string,
        projectId: string,
        analysisId: string,
        user: AuthenticatedUser,
        vulnerabilityId: string,
        workspace: string
    ): Promise<VulnerabilityDetails> {
        // Check if the user is allowed to view this analysis result
        await this.analysisResultsService.checkAccess(orgId, projectId, analysisId, user);

        const vulnMatch = await this.getVuln(analysisId, workspace, vulnerabilityId);
        const dependencyData = await this.getDependency(
            analysisId,
            workspace,
            vulnMatch.AffectedDependency,
            vulnMatch.AffectedVersion
        );
        const packageManager = await this.getPackageManager(analysisId);

        let nvdVuln;
        let osvVuln;
        let friendsOfPhpVuln;

        try {
            nvdVuln = await this.nvdRepository.getVuln(vulnerabilityId);
        } catch (error) {
            console.error(error);
        }

        try {
            if (vulnerabilityId.startsWith('CVE')) {
                osvVuln = await this.osvRepository.getVulnCVE(vulnerabilityId);
            } else {
                osvVuln = await this.osvRepository.getVulnGHSA(vulnerabilityId);
            }
        } catch (error) {
            console.error(error);
        }

        try {
            if (vulnerabilityId.startsWith('CVE')) {
                friendsOfPhpVuln = await this.friendsOfPhpRepository.getVuln(vulnerabilityId);
            }
        } catch (error) {
            console.error(error);
        }

        // If neither NVD nor OSV data found, the vulnerability doesn't exist
        if (!nvdVuln && !osvVuln) {
            throw new EntityNotFound();
        }

        // In case there was a conflict we generate the report information from the report that was considered "correct"
        if (vulnMatch.Conflict && vulnMatch.Conflict.ConflictWinner == 'NVD') {
            // The report from the NVD was considered correct
            return await this.nvdReportGenerator.genReport(
                vulnMatch,
                packageManager,
                dependencyData,
                osvVuln,
                nvdVuln,
                friendsOfPhpVuln || undefined
            );
        } else if (vulnMatch.Conflict && vulnMatch.Conflict.ConflictWinner == 'OSV') {
            // The report from the OSV was considered correct
            return await this.osvReportGenerator.genReport(
                vulnMatch,
                packageManager,
                dependencyData,
                osvVuln,
                nvdVuln,
                friendsOfPhpVuln || undefined
            );
        } else {
            // In case there was no conflict we generate the report information from the OSV database
            return await this.osvReportGenerator.genReport(
                vulnMatch,
                packageManager,
                dependencyData,
                osvVuln,
                nvdVuln,
                friendsOfPhpVuln || undefined
            );
        }
    }

    private async getPackageManager(analysis_id: string): Promise<string> {
        const { mergedSbom } = await this.sbomUtilsService.getMergedSbomResults(analysis_id);
        return mergedSbom.analysis_info.package_manager;
    }

    private async getDependency(
        analysis_id: string,
        workspace: string,
        affected_dependency_name: string,
        affected_dependency_version: string
    ): Promise<Dependency | undefined> {
        const sbomInfo = await this.sbomUtilsService.getSbomResult(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in sbomInfo.workspaces)) {
            throw new UnknownWorkspace();
        }

        // Check if this is a framework vulnerability (starts with 'framework-')
        if (affected_dependency_name.startsWith('framework-')) {
            // Framework vulnerabilities don't have corresponding SBOM entries
            // Return undefined to indicate no dependency data is available
            return undefined;
        }

        if (affected_dependency_name in sbomInfo.workspaces[workspace].dependencies) {
            return sbomInfo.workspaces[workspace].dependencies[affected_dependency_name][
                affected_dependency_version
            ];
        }

        throw new EntityNotFound();
    }

    private async getPatch(
        analysis_id: string,
        workspace: string,
        vuln_id: string,
        affected_dependency_name: string,
        affected_dependency_version: string
    ): Promise<PatchInfo> {
        const patchInfo = await this.patchingUtilsService.getPatchingResult(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in patchInfo.workspaces)) {
            throw new UnknownWorkspace();
        }

        if (
            affected_dependency_name + '@' + affected_dependency_version in
            patchInfo.workspaces[workspace].dev_patches
        ) {
            return patchInfo.workspaces[workspace].dev_patches[
                affected_dependency_name + '@' + affected_dependency_version
            ];
        }

        throw new EntityNotFound();
    }

    private async getVuln(
        analysis_id: string,
        workspace: string,
        vulnerability_id: string
    ): Promise<Vulnerability> {
        const vulns: VulnsOutput =
            await this.vulnerabilitiesUtilsService.getVulnsResult(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in vulns.workspaces)) {
            throw new UnknownWorkspace();
        }

        const vulnerabilities = vulns.workspaces[workspace].Vulnerabilities;
        
        // Handle both individual vulnerabilities and merged vulnerabilities
        for (const vuln of vulnerabilities) {
            if (vuln.VulnerabilityId == vulnerability_id) {
                return vuln;
            }
            
            // Check if this is a merged vulnerability (VulnerabilityMerged)
            if ((vuln as any).Vulnerability == vulnerability_id) {
                // Convert merged vulnerability to individual format by taking the first affected dependency
                const merged = vuln as any; // VulnerabilityMerged type
                if (merged.Affected && merged.Affected.length > 0) {
                    const firstAffected = merged.Affected[0];
                    return {
                        Id: firstAffected.Id || '',
                        Sources: firstAffected.Sources || [],
                        AffectedDependency: firstAffected.AffectedDependency,
                        AffectedVersion: firstAffected.AffectedVersion,
                        VulnerabilityId: firstAffected.VulnerabilityId,
                        Severity: firstAffected.Severity,
                        Weaknesses: firstAffected.Weaknesses,
                        OSVMatch: firstAffected.OSVMatch,
                        NVDMatch: firstAffected.NVDMatch,
                        Conflict: firstAffected.Conflict
                    } as Vulnerability;
                }
            }
        }

        throw new EntityNotFound();
    }
}
