import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import {
  valid as semverValid,
  coerce as semverCoerce,
  lt as semverLt,
  gte as semverGte,
  lte as semverLte,
} from "semver";
import { Repository, In } from "typeorm";
import { FriendsOfPhp } from "../friendsofphp/friendsofphp.entity";
import { NVD } from "../nvd/nvd.entity";
import { OSV } from "../osv/osv.entity";
import { PackageEcosystem } from "../package/outdated.types";
import { PackageVulnerability } from "./package-vulnerability.entity";
import {
  VulnerabilityCheckRequestBody,
  VulnerabilityCheckResponse,
  PackageVulnerabilityResult,
  VulnerabilityInfo,
  VulnerabilityCheckPackageItem,
} from "./vulnerability-check.types";

// Type for affected range from OSV data
interface AffectedRange {
  introduced?: string | undefined;
  fixed?: string | undefined;
  last_affected?: string | undefined;
}

// Type for extracted vulnerability info from any source
interface ExtractedVulnInfo {
  vulnerabilityId: string;
  severity: string;
  cvssScore?: number | undefined;
  cveId?: string | undefined;
  summary?: string | undefined;
  affectedRanges: AffectedRange[];
  fixedVersion?: string | undefined;
  source: string;
}

// Types for OSV JSON structures
interface OsvSeverity {
  type?: string;
  score?: string | number;
}

interface OsvEvent {
  introduced?: string;
  fixed?: string;
  last_affected?: string;
}

interface OsvRange {
  type?: string;
  events?: OsvEvent[];
}

interface OsvAffectedPackage {
  package?: { name?: string };
  severity?: OsvSeverity[];
  ranges?: OsvRange[];
}

// Types for NVD JSON structures
interface NvdCvssData {
  baseScore?: number;
  baseSeverity?: string;
}

interface NvdCvssMetric {
  cvssData?: NvdCvssData;
  baseSeverity?: string;
}

interface NvdMetrics {
  cvssMetricV31?: NvdCvssMetric[];
  cvssMetricV30?: NvdCvssMetric[];
  cvssMetricV2?: NvdCvssMetric[];
}

interface NvdDescription {
  lang?: string;
  value?: string;
}

// Type for FriendsOfPhp branches
interface FopBranch {
  versions?: string[];
}

@Injectable()
export class VulnerabilityCheckService {
  // Simple in-memory cache for vulnerability lookups
  private cache = new Map<
    string,
    { data: ExtractedVulnInfo[]; timestamp: number }
  >();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  private readonly CACHE_MAX_SIZE = 5000;

  constructor(
    @InjectRepository(PackageVulnerability, "knowledge")
    private packageVulnerabilityRepository: Repository<PackageVulnerability>,
  ) {}

  /**
   * Check multiple packages for known vulnerabilities
   */
  async checkVulnerabilities(
    request: VulnerabilityCheckRequestBody,
  ): Promise<VulnerabilityCheckResponse> {
    const results: PackageVulnerabilityResult[] = [];
    let totalVulnerabilities = 0;

    // Group packages by ecosystem
    const npmPackages = request.packages.filter(
      (p) => p.ecosystem === PackageEcosystem.NPM,
    );
    const packagistPackages = request.packages.filter(
      (p) => p.ecosystem === PackageEcosystem.PACKAGIST,
    );

    if (npmPackages.length > 0) {
      const npmResults = await this.batchCheckPackages(
        npmPackages,
        PackageEcosystem.NPM,
      );
      results.push(...npmResults);
      totalVulnerabilities += npmResults.reduce(
        (sum, r) => sum + r.vulnerabilities.length,
        0,
      );
    }

    if (packagistPackages.length > 0) {
      const packagistResults = await this.batchCheckPackages(
        packagistPackages,
        PackageEcosystem.PACKAGIST,
      );
      results.push(...packagistResults);
      totalVulnerabilities += packagistResults.reduce(
        (sum, r) => sum + r.vulnerabilities.length,
        0,
      );
    }

    return {
      packages: results,
      totalVulnerabilities,
      checkedAt: new Date().toISOString(),
    };
  }

  private async batchCheckPackages(
    packages: VulnerabilityCheckPackageItem[],
    ecosystem: PackageEcosystem,
  ): Promise<PackageVulnerabilityResult[]> {
    const results: PackageVulnerabilityResult[] = [];
    const packageNames = packages.map((p) => p.name);

    // Check cache first
    const uncachedNames: string[] = [];
    const cachedVulns = new Map<string, ExtractedVulnInfo[]>();

    for (const name of packageNames) {
      const cached = this.getFromCache(name, ecosystem);
      if (cached) {
        cachedVulns.set(name, cached);
      } else {
        uncachedNames.push(name);
      }
    }

    // Batch query uncached packages with relations
    if (uncachedNames.length > 0) {
      const dbVulns = await this.packageVulnerabilityRepository.find({
        where: {
          packageName: In(uncachedNames),
          packageEcosystem: ecosystem,
        },
        relations: ["osv", "nvd", "friendsofphp"],
      });

      // Group by package name and extract vulnerability info
      const vulnsByPackage = new Map<string, ExtractedVulnInfo[]>();
      for (const pv of dbVulns) {
        const extracted = this.extractVulnInfo(pv);
        if (extracted) {
          const existing = vulnsByPackage.get(pv.packageName) ?? [];
          existing.push(extracted);
          vulnsByPackage.set(pv.packageName, existing);
        }
      }

      // Cache results
      for (const name of uncachedNames) {
        const vulns = vulnsByPackage.get(name) ?? [];
        this.addToCache(name, ecosystem, vulns);
        cachedVulns.set(name, vulns);
      }
    }

    // Build results by checking version ranges
    for (const pkg of packages) {
      const allVulns = cachedVulns.get(pkg.name) ?? [];
      const matchingVulns: VulnerabilityInfo[] = [];

      for (const vuln of allVulns) {
        if (this.isVersionAffected(pkg.version, vuln.affectedRanges)) {
          const vulnInfo: VulnerabilityInfo = {
            vulnerabilityId: vuln.vulnerabilityId,
            severity: vuln.severity,
            summary: vuln.summary ?? "",
            affectedRanges: JSON.stringify(vuln.affectedRanges),
            source: vuln.source,
          };
          if (vuln.cveId) {
            vulnInfo.cveId = vuln.cveId;
          }
          if (vuln.cvssScore !== undefined) {
            vulnInfo.cvssScore = vuln.cvssScore;
          }
          if (vuln.fixedVersion) {
            vulnInfo.fixedVersion = vuln.fixedVersion;
          }
          matchingVulns.push(vulnInfo);
        }
      }

      results.push({
        packageName: pkg.name,
        packageVersion: pkg.version,
        ecosystem,
        isVulnerable: matchingVulns.length > 0,
        vulnerabilities: matchingVulns,
      });
    }

    return results;
  }

  /**
   * Extract vulnerability info from a PackageVulnerability with its related entity
   */
  private extractVulnInfo(pv: PackageVulnerability): ExtractedVulnInfo | null {
    if (pv.osv) {
      return this.extractFromOsv(pv.osv, pv.packageName);
    }
    if (pv.nvd) {
      return this.extractFromNvd(pv.nvd);
    }
    if (pv.friendsofphp) {
      return this.extractFromFriendsOfPhp(pv.friendsofphp);
    }
    return null;
  }

  /**
   * Extract vulnerability info from OSV entity
   */
  private extractFromOsv(osv: OSV, packageName: string): ExtractedVulnInfo {
    const affected = this.findAffectedPackage(osv.affected, packageName);
    const severity = this.extractOsvSeverity(osv.severity, affected?.severity);
    const cvssScore = this.extractOsvCvssScore(
      osv.severity,
      affected?.severity,
    );
    const affectedRanges = this.extractOsvRanges(affected?.ranges);
    const fixedVersion = this.findFixedVersion(affectedRanges);

    return {
      vulnerabilityId: osv.osv_id,
      severity,
      cvssScore,
      cveId: osv.cve || undefined,
      summary: osv.summary || undefined,
      affectedRanges,
      fixedVersion,
      source: "osv",
    };
  }

  /**
   * Extract vulnerability info from NVD entity
   */
  private extractFromNvd(nvd: NVD): ExtractedVulnInfo {
    const severity = this.extractNvdSeverity(nvd.metrics as NvdMetrics | null);
    const cvssScore = this.extractNvdCvssScore(
      nvd.metrics as NvdMetrics | null,
    );
    const summary = this.extractNvdDescription(nvd.descriptions);

    return {
      vulnerabilityId: nvd.nvd_id,
      severity,
      cvssScore,
      cveId: nvd.nvd_id,
      summary,
      affectedRanges: [], // NVD uses CPE, not semver ranges
      source: "nvd",
    };
  }

  /**
   * Extract vulnerability info from FriendsOfPhp entity
   */
  private extractFromFriendsOfPhp(fop: FriendsOfPhp): ExtractedVulnInfo {
    const affectedRanges = this.extractFopRanges(fop.branches);

    return {
      vulnerabilityId: fop.advisory_id,
      severity: "unknown",
      cveId: fop.cve || undefined,
      summary: fop.title || undefined,
      affectedRanges,
      source: "friendsofphp",
    };
  }

  private findAffectedPackage(
    affected: unknown,
    packageName: string,
  ): OsvAffectedPackage | null {
    if (!Array.isArray(affected)) return null;
    return (
      (affected as OsvAffectedPackage[]).find(
        (a) => a.package?.name?.toLowerCase() === packageName.toLowerCase(),
      ) ?? null
    );
  }

  private extractOsvSeverity(
    topSeverity: unknown,
    affectedSeverity: unknown,
  ): string {
    const severities = (affectedSeverity ?? topSeverity) as
      | OsvSeverity[]
      | undefined;
    if (!Array.isArray(severities)) return "unknown";

    for (const sev of severities) {
      if (sev.type === "CVSS_V3" || sev.type === "CVSS_V2") {
        const score = this.parseScore(sev.score);
        if (score >= 9.0) return "critical";
        if (score >= 7.0) return "high";
        if (score >= 4.0) return "medium";
        if (score > 0) return "low";
      }
    }
    return "unknown";
  }

  private extractOsvCvssScore(
    topSeverity: unknown,
    affectedSeverity: unknown,
  ): number | undefined {
    const severities = (affectedSeverity ?? topSeverity) as
      | OsvSeverity[]
      | undefined;
    if (!Array.isArray(severities)) return undefined;

    for (const sev of severities) {
      const score = this.parseScore(sev.score);
      if (score > 0) return score;
    }
    return undefined;
  }

  private extractOsvRanges(ranges: unknown): AffectedRange[] {
    if (!Array.isArray(ranges)) return [];

    const result: AffectedRange[] = [];
    for (const r of ranges as OsvRange[]) {
      if (r.type === "SEMVER" || r.type === "ECOSYSTEM") {
        for (const event of r.events ?? []) {
          const ar: AffectedRange = {};
          if (event.introduced) ar.introduced = event.introduced;
          if (event.fixed) ar.fixed = event.fixed;
          if (event.last_affected) ar.last_affected = event.last_affected;
          if (ar.introduced || ar.fixed || ar.last_affected) {
            result.push(ar);
          }
        }
      }
    }
    return result;
  }

  private extractNvdSeverity(metrics: NvdMetrics | null | undefined): string {
    if (!metrics) return "unknown";

    const v31 = metrics.cvssMetricV31?.[0];
    if (v31) {
      return v31.cvssData?.baseSeverity?.toLowerCase() ?? "unknown";
    }
    const v30 = metrics.cvssMetricV30?.[0];
    if (v30) {
      return v30.cvssData?.baseSeverity?.toLowerCase() ?? "unknown";
    }
    const v2 = metrics.cvssMetricV2?.[0];
    if (v2) {
      return v2.baseSeverity?.toLowerCase() ?? "unknown";
    }
    return "unknown";
  }

  private extractNvdCvssScore(
    metrics: NvdMetrics | null | undefined,
  ): number | undefined {
    if (!metrics) return undefined;

    const v31 = metrics.cvssMetricV31?.[0];
    if (v31) {
      return v31.cvssData?.baseScore;
    }
    const v30 = metrics.cvssMetricV30?.[0];
    if (v30) {
      return v30.cvssData?.baseScore;
    }
    const v2 = metrics.cvssMetricV2?.[0];
    if (v2) {
      return v2.cvssData?.baseScore;
    }
    return undefined;
  }

  private extractNvdDescription(descriptions: unknown): string | undefined {
    if (!Array.isArray(descriptions)) return undefined;

    const typedDescs = descriptions as NvdDescription[];
    const en = typedDescs.find((d) => d.lang === "en");
    if (en?.value) return en.value;
    if (typedDescs[0]?.value) return typedDescs[0].value;
    return undefined;
  }

  private extractFopRanges(branches: unknown): AffectedRange[] {
    if (!branches || typeof branches !== "object") return [];

    const result: AffectedRange[] = [];
    for (const branch of Object.values(branches as Record<string, FopBranch>)) {
      if (Array.isArray(branch.versions) && branch.versions.length >= 2) {
        result.push({
          introduced: branch.versions[0],
          fixed: branch.versions[1],
        });
      }
    }
    return result;
  }

  private parseScore(score: string | number | undefined): number {
    if (typeof score === "number") return score;
    if (typeof score === "string") {
      const parsed = parseFloat(score);
      if (!isNaN(parsed)) return parsed;
    }
    return 0;
  }

  private findFixedVersion(ranges: AffectedRange[]): string | undefined {
    for (const r of ranges) {
      if (r.fixed) return r.fixed;
    }
    return undefined;
  }

  /**
   * Check if a version is affected by the given version ranges
   */
  private isVersionAffected(version: string, ranges: AffectedRange[]): boolean {
    if (!ranges || ranges.length === 0) {
      return false;
    }

    const cleanVersion = this.cleanVersion(version);
    if (!cleanVersion) {
      return false;
    }

    for (const range of ranges) {
      if (this.isVersionInRange(cleanVersion, range)) {
        return true;
      }
    }

    return false;
  }

  private isVersionInRange(version: string, range: AffectedRange): boolean {
    const introduced = range.introduced
      ? this.cleanVersion(range.introduced)
      : null;
    const fixed = range.fixed ? this.cleanVersion(range.fixed) : null;
    const lastAffected = range.last_affected
      ? this.cleanVersion(range.last_affected)
      : null;

    if (introduced && fixed) {
      try {
        if (introduced === "0.0.0" || range.introduced === "0") {
          return semverLt(version, fixed);
        }
        return semverGte(version, introduced) && semverLt(version, fixed);
      } catch {
        return version >= introduced && version < fixed;
      }
    }

    if (introduced && lastAffected) {
      try {
        if (introduced === "0.0.0" || range.introduced === "0") {
          return semverLte(version, lastAffected);
        }
        return (
          semverGte(version, introduced) && semverLte(version, lastAffected)
        );
      } catch {
        return version >= introduced && version <= lastAffected;
      }
    }

    if (fixed && !introduced) {
      try {
        return semverLt(version, fixed);
      } catch {
        return version < fixed;
      }
    }

    if (lastAffected && !introduced) {
      try {
        return semverLte(version, lastAffected);
      } catch {
        return version <= lastAffected;
      }
    }

    if (introduced && !fixed && !lastAffected) {
      try {
        if (introduced === "0.0.0" || range.introduced === "0") {
          return true;
        }
        return semverGte(version, introduced);
      } catch {
        return version >= introduced;
      }
    }

    return false;
  }

  private cleanVersion(version: string): string | null {
    if (!version) return null;
    if (version === "0") return "0.0.0";

    const valid = semverValid(version);
    if (valid) return valid;

    const coerced = semverCoerce(version);
    if (coerced) return coerced.version;

    return version;
  }

  private getCacheKey(name: string, ecosystem: PackageEcosystem): string {
    return `${ecosystem}:${name}`;
  }

  private getFromCache(
    name: string,
    ecosystem: PackageEcosystem,
  ): ExtractedVulnInfo[] | null {
    const key = this.getCacheKey(name, ecosystem);
    const entry = this.cache.get(key);

    if (!entry) return null;
    if (Date.now() - entry.timestamp > this.CACHE_TTL) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  private addToCache(
    name: string,
    ecosystem: PackageEcosystem,
    vulnerabilities: ExtractedVulnInfo[],
  ): void {
    if (this.cache.size >= this.CACHE_MAX_SIZE) {
      const oldestKeys = Array.from(this.cache.keys()).slice(0, 500);
      oldestKeys.forEach((k) => this.cache.delete(k));
    }

    const key = this.getCacheKey(name, ecosystem);
    this.cache.set(key, {
      data: vulnerabilities,
      timestamp: Date.now(),
    });
  }
}
