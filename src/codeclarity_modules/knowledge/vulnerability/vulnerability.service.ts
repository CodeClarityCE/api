import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, SelectQueryBuilder } from 'typeorm';
import { NVD } from '../nvd/nvd.entity';
import { OSV } from '../osv/osv.entity';
import { TypedPaginatedData } from 'src/types/pagination.types';

export interface VulnerabilitySearchResult {
    id: string;
    aliases: string[];
    description: string;
    severity?: string;
    published_date?: string;
    source: 'NVD' | 'OSV';
    sources?: Array<{
        id: string;
        source: 'NVD' | 'OSV';
        description: string;
        severity?: string;
        published_date?: string;
    }>;
}

export interface VulnerabilitySearchRequest {
    query: string;
    page?: number;
    limit?: number;
    source?: 'NVD' | 'OSV' | 'ALL';
}

@Injectable()
export class VulnerabilitySearchService {
    // Simple in-memory cache for frequently searched CVEs
    private searchCache = new Map<
        string,
        { data: TypedPaginatedData<VulnerabilitySearchResult>; timestamp: number }
    >();
    private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
    private readonly CACHE_MAX_SIZE = 1000; // Maximum cache entries

    constructor(
        @InjectRepository(NVD, 'knowledge')
        private nvdRepository: Repository<NVD>,
        @InjectRepository(OSV, 'knowledge')
        private osvRepository: Repository<OSV>
    ) {}

    /**
     * Search vulnerabilities by CVE ID, aliases, or description
     * @param request Search request parameters
     * @returns Paginated vulnerability search results
     */
    async searchVulnerabilities(
        request: VulnerabilitySearchRequest
    ): Promise<TypedPaginatedData<VulnerabilitySearchResult>> {
        const { query, page = 0, limit = 20, source = 'ALL' } = request;
        const maxLimit = Math.min(limit, 100); // Cap at 100 results per page
        const offset = page * maxLimit;

        // Check cache for exact CVE matches (most common case)
        const cacheKey = `${query.toUpperCase()}_${page}_${maxLimit}_${source}`;
        if (this.isExactCVEQuery(query)) {
            const cached = this.getFromCache(cacheKey);
            if (cached) {
                return cached;
            }
        }

        const results: VulnerabilitySearchResult[] = [];
        let totalCount = 0;

        try {
            // Run searches in parallel for better performance
            const searchPromises: Promise<{ data: VulnerabilitySearchResult[]; total: number }>[] =
                [];

            if (source === 'ALL' || source === 'NVD') {
                searchPromises.push(this.searchNVDVulnerabilities(query, offset, maxLimit));
            }

            if (source === 'ALL' || source === 'OSV') {
                searchPromises.push(this.searchOSVVulnerabilities(query, offset, maxLimit));
            }

            const searchResults = await Promise.all(searchPromises);

            for (const result of searchResults) {
                results.push(...result.data);
                totalCount += result.total;
            }
        } catch (error) {
            console.error('Error during vulnerability search:', error);
            throw error;
        }

        // Remove duplicates based on ID (prefer NVD entries)
        const uniqueResults = this.deduplicateResults(results);

        // Sort by relevance (exact matches first, then alphabetically)
        uniqueResults.sort((a, b) => {
            const aExactMatch = this.isExactMatch(query, a);
            const bExactMatch = this.isExactMatch(query, b);

            if (aExactMatch && !bExactMatch) return -1;
            if (!aExactMatch && bExactMatch) return 1;

            return a.id.localeCompare(b.id);
        });

        // Apply pagination to final results
        const paginatedResults = uniqueResults.slice(0, maxLimit);

        const result = {
            data: paginatedResults,
            page,
            entry_count: paginatedResults.length,
            entries_per_page: maxLimit,
            total_entries: totalCount,
            total_pages: Math.ceil(totalCount / maxLimit),
            matching_count: totalCount,
            filter_count: {}
        };

        // Cache exact CVE matches for faster subsequent searches
        if (this.isExactCVEQuery(query)) {
            this.addToCache(cacheKey, result);
        }

        return result;
    }

    private async searchNVDVulnerabilities(
        query: string,
        offset: number,
        limit: number
    ): Promise<{ data: VulnerabilitySearchResult[]; total: number }> {
        const queryBuilder = this.nvdRepository
            .createQueryBuilder('nvd')
            .select(['nvd.nvd_id', 'nvd.descriptions', 'nvd.published', 'nvd.metrics']);

        // Optimize: Use exact match first for better performance with new indexes
        const isExactCVEMatch = query.toUpperCase().startsWith('CVE-');
        if (isExactCVEMatch) {
            // Use the new upper() index for exact matches
            queryBuilder
                .where('upper(nvd.nvd_id) = :exactQuery', { exactQuery: query.toUpperCase() })
                .orWhere('nvd.nvd_id ILIKE :query', { query: `%${query}%` })
                .orWhere('CAST(nvd.descriptions AS TEXT) ILIKE :query', { query: `%${query}%` });
        } else {
            // Use full text search indexes for text queries
            queryBuilder.where(
                "to_tsvector('english', nvd_id) @@ to_tsquery('english', :tsQuery) OR to_tsvector('english', descriptions::text) @@ to_tsquery('english', :tsQuery)",
                { tsQuery: query.replace(/[^a-zA-Z0-9-]/g, ' ').trim() }
            );
        }

        // Optimize: For search UI, we don't need exact total count - just get the results quickly
        const nvdEntries = await queryBuilder.skip(offset).take(limit).getMany();

        // Estimate total (much faster than counting all)
        const total =
            nvdEntries.length < limit ? nvdEntries.length : nvdEntries.length + offset + 1;

        const results: VulnerabilitySearchResult[] = nvdEntries.map((nvd) => ({
            id: nvd.nvd_id,
            aliases: [nvd.nvd_id], // NVD IDs are primary, may have aliases in descriptions
            description: this.extractDescription(nvd.descriptions),
            severity: this.extractNVDSeverity(nvd.metrics),
            published_date: nvd.published,
            source: 'NVD' as const
        }));

        return { data: results, total };
    }

    private async searchOSVVulnerabilities(
        query: string,
        offset: number,
        limit: number
    ): Promise<{ data: VulnerabilitySearchResult[]; total: number }> {
        const queryBuilder = this.osvRepository
            .createQueryBuilder('osv')
            .select([
                'osv.osv_id',
                'osv.aliases',
                'osv.summary',
                'osv.published',
                'osv.database_specific'
            ]);

        // Optimize: Search differently based on query type, using new indexes
        const isExactCVEMatch = query.toUpperCase().startsWith('CVE-');
        if (isExactCVEMatch) {
            // For CVE searches, use upper() index and GIN index for aliases
            queryBuilder
                .where('upper(osv.osv_id) = :exactQuery', { exactQuery: query.toUpperCase() })
                .orWhere('aliases @> :aliasJson', {
                    aliasJson: JSON.stringify([query.toUpperCase()])
                })
                .orWhere('osv.osv_id ILIKE :query', { query: `%${query}%` })
                .orWhere(
                    "osv.aliases IS NOT NULL AND jsonb_typeof(osv.aliases) = 'array' AND EXISTS (SELECT 1 FROM jsonb_array_elements_text(osv.aliases) alias WHERE alias ILIKE :aliasQuery)",
                    { aliasQuery: `%${query}%` }
                );
        } else {
            // Use full text search indexes for text queries
            queryBuilder
                .where(
                    "to_tsvector('english', osv_id) @@ to_tsquery('english', :tsQuery) OR to_tsvector('english', summary) @@ to_tsquery('english', :tsQuery)",
                    { tsQuery: query.replace(/[^a-zA-Z0-9-]/g, ' ').trim() }
                )
                .orWhere(
                    "osv.aliases IS NOT NULL AND jsonb_typeof(osv.aliases) = 'array' AND EXISTS (SELECT 1 FROM jsonb_array_elements_text(osv.aliases) alias WHERE alias ILIKE :aliasQuery)",
                    { aliasQuery: `%${query}%` }
                );
        }

        // Optimize: For search UI, we don't need exact total count - just get the results quickly
        const osvEntries = await queryBuilder.skip(offset).take(limit).getMany();

        // Estimate total (much faster than counting all)
        const total =
            osvEntries.length < limit ? osvEntries.length : osvEntries.length + offset + 1;

        const results: VulnerabilitySearchResult[] = osvEntries.map((osv) => ({
            id: osv.osv_id,
            aliases: this.extractAliases(osv.aliases),
            description: osv.summary || '',
            severity: this.extractOSVSeverity(osv.database_specific),
            published_date: osv.published,
            source: 'OSV' as const
        }));

        return { data: results, total };
    }

    private addSearchConditions(
        queryBuilder: SelectQueryBuilder<any>,
        idColumn: string,
        descriptionColumn: string,
        query: string
    ): void {
        const searchTerm = `%${query}%`;

        // For NVD JSONB descriptions column, cast to text for ILIKE search
        if (descriptionColumn.includes('descriptions')) {
            queryBuilder.where(
                `${idColumn} ILIKE :query OR CAST(${descriptionColumn} AS TEXT) ILIKE :query`,
                { query: searchTerm }
            );
        } else {
            // For regular text columns like OSV summary
            queryBuilder.where(`${idColumn} ILIKE :query OR ${descriptionColumn} ILIKE :query`, {
                query: searchTerm
            });
        }
    }

    private extractDescription(descriptions: any): string {
        if (!descriptions) return '';

        if (Array.isArray(descriptions)) {
            const englishDesc = descriptions.find((desc: any) => desc.lang === 'en');
            return englishDesc?.value || descriptions[0]?.value || '';
        }

        if (typeof descriptions === 'object' && descriptions.en) {
            return descriptions.en;
        }

        return String(descriptions);
    }

    private extractAliases(aliases: any): string[] {
        if (!aliases) return [];

        if (Array.isArray(aliases)) return aliases;

        if (typeof aliases === 'string') {
            try {
                return JSON.parse(aliases);
            } catch {
                return [aliases];
            }
        }

        return [];
    }

    private calculateSeverity(score: number | null): string | undefined {
        if (!score) return undefined;

        if (score >= 9.0) return 'CRITICAL';
        if (score >= 7.0) return 'HIGH';
        if (score >= 4.0) return 'MEDIUM';
        if (score >= 0.1) return 'LOW';
        return 'NONE';
    }

    private extractNVDSeverity(metrics: any): string | undefined {
        try {
            // Try to extract CVSS score from metrics JSON
            if (!metrics) return undefined;

            // Check for CVSS v3.1
            if (metrics.cvssMetricV31 && metrics.cvssMetricV31[0]?.cvssData?.baseScore) {
                return this.calculateSeverity(metrics.cvssMetricV31[0].cvssData.baseScore);
            }

            // Check for CVSS v3.0
            if (metrics.cvssMetricV30 && metrics.cvssMetricV30[0]?.cvssData?.baseScore) {
                return this.calculateSeverity(metrics.cvssMetricV30[0].cvssData.baseScore);
            }

            // Check for CVSS v2
            if (metrics.cvssMetricV2 && metrics.cvssMetricV2[0]?.cvssData?.baseScore) {
                return this.calculateSeverity(metrics.cvssMetricV2[0].cvssData.baseScore);
            }

            return undefined;
        } catch {
            return undefined;
        }
    }

    private extractOSVSeverity(databaseSpecific: any): string | undefined {
        try {
            if (databaseSpecific?.severity) {
                return String(databaseSpecific.severity).toUpperCase();
            }
        } catch {
            // Ignore parsing errors
        }
        return undefined;
    }

    private deduplicateResults(results: VulnerabilitySearchResult[]): VulnerabilitySearchResult[] {
        const groupedByCVE = new Map<string, VulnerabilitySearchResult[]>();

        // Group results by CVE ID (found in id or aliases)
        for (const result of results) {
            const cveIds = this.extractCVEIds(result);
            if (cveIds.length > 0) {
                // Use the first CVE ID as the primary key
                const primaryCVE = cveIds[0];
                if (!groupedByCVE.has(primaryCVE)) {
                    groupedByCVE.set(primaryCVE, []);
                }
                groupedByCVE.get(primaryCVE)!.push(result);
            } else {
                // No CVE ID found, treat as separate entry
                groupedByCVE.set(result.id, [result]);
            }
        }

        // Convert grouped results back to flat list with combined sources
        const unique: VulnerabilitySearchResult[] = [];
        for (const [cveId, group] of groupedByCVE) {
            if (group.length === 1) {
                // Single source, keep as is
                unique.push(group[0]);
            } else {
                // Multiple sources, create combined entry
                const nvdEntry = group.find((r) => r.source === 'NVD');

                // Use NVD as primary if available, otherwise use first entry
                const primary = nvdEntry || group[0];
                const combined: VulnerabilitySearchResult = {
                    ...primary,
                    id: cveId, // Use CVE ID as the primary ID
                    aliases: [...new Set(group.flatMap((r) => r.aliases))],
                    sources: group.map((r) => ({
                        id: r.id,
                        source: r.source,
                        description: r.description,
                        severity: r.severity,
                        published_date: r.published_date
                    }))
                };
                unique.push(combined);
            }
        }

        return unique;
    }

    private extractCVEIds(result: VulnerabilitySearchResult): string[] {
        const cvePattern = /CVE-\d{4}-\d+/gi;
        const cveIds: string[] = [];

        // Check primary ID
        if (result.id.match(cvePattern)) {
            cveIds.push(result.id.toUpperCase());
        }

        // Check aliases
        for (const alias of result.aliases) {
            const matches = alias.match(cvePattern);
            if (matches) {
                cveIds.push(...matches.map((m) => m.toUpperCase()));
            }
        }

        return [...new Set(cveIds)];
    }

    private isExactMatch(query: string, result: VulnerabilitySearchResult): boolean {
        const lowercaseQuery = query.toLowerCase();
        return (
            result.id.toLowerCase() === lowercaseQuery ||
            result.aliases.some((alias) => alias.toLowerCase() === lowercaseQuery)
        );
    }

    private isExactCVEQuery(query: string): boolean {
        // Only cache exact CVE queries like "CVE-2025-5889"
        return /^CVE-\d{4}-\d+$/i.test(query.trim());
    }

    private getFromCache(key: string): TypedPaginatedData<VulnerabilitySearchResult> | null {
        const entry = this.searchCache.get(key);
        if (!entry) return null;

        // Check if cache entry is expired
        if (Date.now() - entry.timestamp > this.CACHE_TTL) {
            this.searchCache.delete(key);
            return null;
        }

        return entry.data;
    }

    private addToCache(key: string, data: TypedPaginatedData<VulnerabilitySearchResult>): void {
        // Prevent cache from growing too large
        if (this.searchCache.size >= this.CACHE_MAX_SIZE) {
            // Remove oldest entries (simple LRU)
            const oldestKeys = Array.from(this.searchCache.keys()).slice(0, 100);
            oldestKeys.forEach((k) => this.searchCache.delete(k));
        }

        this.searchCache.set(key, {
            data,
            timestamp: Date.now()
        });
    }
}
