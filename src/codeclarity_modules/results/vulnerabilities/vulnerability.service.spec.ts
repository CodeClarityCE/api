import { AuthenticatedUser, ROLE } from 'src/base_modules/auth/auth.types';
import { FriendsOfPhpRepository } from 'src/codeclarity_modules/knowledge/friendsofphp/friendsofphp.repository';
import { NVDRepository } from 'src/codeclarity_modules/knowledge/nvd/nvd.repository';
import { OSVRepository } from 'src/codeclarity_modules/knowledge/osv/osv.repository';
import { EntityNotFound, UnknownWorkspace } from 'src/types/error.types';

import { Test, type TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';

import { PatchingUtilsService } from '../patching/utils/utils';
import { Result } from '../result.entity';
import { AnalysisResultsService } from '../results.service';
import { SbomUtilsService } from '../sbom/utils/utils';

import { NVDReportGenerator, OSVReportGenerator } from './services/reportGenerator';
import { VulnerabilitiesUtilsService } from './utils/utils.service';
import { VulnerabilityService } from './vulnerability.service';




describe('VulnerabilityService', () => {
    let service: VulnerabilityService;
    let analysisResultsService: AnalysisResultsService;
    let osvRepository: OSVRepository;
    let nvdRepository: NVDRepository;
    let osvReportGenerator: OSVReportGenerator;
    let nvdReportGenerator: NVDReportGenerator;
    let vulnerabilitiesUtilsService: VulnerabilitiesUtilsService;
    let sbomUtilsService: SbomUtilsService;

    const mockUser = new AuthenticatedUser('user-123', [ROLE.USER], true);

    const mockVulnerability = {
        VulnerabilityId: 'CVE-2024-1234',
        AffectedDependency: 'package1',
        AffectedVersion: '1.0.0',
        Conflict: null
    };

    const mockVulnerabilityWithConflict = {
        VulnerabilityId: 'CVE-2024-5678',
        AffectedDependency: 'package2',
        AffectedVersion: '2.0.0',
        Conflict: {
            ConflictWinner: 'NVD'
        }
    };

    const mockVulnsOutput = {
        workspaces: {
            default: {
                Vulnerabilities: [mockVulnerability, mockVulnerabilityWithConflict]
            }
        }
    };

    const mockSbomOutput = {
        workspaces: {
            default: {
                dependencies: {
                    package1: {
                        '1.0.0': {
                            name: 'package1',
                            version: '1.0.0',
                            license: 'MIT'
                        }
                    }
                }
            }
        },
        analysis_info: {
            package_manager: 'NPM'
        }
    };

    const mockOSVVuln = {
        id: 'CVE-2024-1234',
        osv_id: 'CVE-2024-1234',
        summary: 'Test vulnerability',
        severity: 'HIGH'
    };

    const mockNVDVuln = {
        id: 'CVE-2024-1234',
        description: 'Test NVD vulnerability',
        cvss: { baseScore: 7.5 }
    };

    const mockVulnerabilityDetails = {
        vulnerability_id: 'CVE-2024-1234',
        affected_dependency: 'package1',
        affected_version: '1.0.0',
        severity: 'HIGH',
        description: 'Test vulnerability details'
    };

    const mockAnalysisResultsService = {
        checkAccess: jest.fn()
    };

    const mockOSVRepository = {
        getVulnCVE: jest.fn(),
        getVulnGHSA: jest.fn()
    };

    const mockNVDRepository = {
        getVuln: jest.fn()
    };
    const mockFriendsOfPhpRepository = {
        getVuln: jest.fn()
    };

    const mockOSVReportGenerator = {
        genReport: jest.fn()
    };

    const mockNVDReportGenerator = {
        genReport: jest.fn()
    };

    const mockVulnerabilitiesUtilsService = {
        getVulnsResult: jest.fn()
    };

    const mockSbomUtilsService = {
        getSbomResult: jest.fn(),
        getMergedSbomResults: jest.fn()
    };

    const mockPatchingUtilsService = {
        getPatchingResult: jest.fn()
    };

    const mockResultRepository = {
        find: jest.fn(),
        findOne: jest.fn()
    };

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [
                VulnerabilityService,
                {
                    provide: AnalysisResultsService,
                    useValue: mockAnalysisResultsService
                },
                {
                    provide: OSVRepository,
                    useValue: mockOSVRepository
                },
                {
                    provide: NVDRepository,
                    useValue: mockNVDRepository
                },
                {
                    provide: FriendsOfPhpRepository,
                    useValue: mockFriendsOfPhpRepository
                },
                {
                    provide: OSVReportGenerator,
                    useValue: mockOSVReportGenerator
                },
                {
                    provide: NVDReportGenerator,
                    useValue: mockNVDReportGenerator
                },
                {
                    provide: VulnerabilitiesUtilsService,
                    useValue: mockVulnerabilitiesUtilsService
                },
                {
                    provide: SbomUtilsService,
                    useValue: mockSbomUtilsService
                },
                {
                    provide: PatchingUtilsService,
                    useValue: mockPatchingUtilsService
                },
                {
                    provide: getRepositoryToken(Result, 'codeclarity'),
                    useValue: mockResultRepository
                }
            ]
        }).compile();

        service = module.get<VulnerabilityService>(VulnerabilityService);
        analysisResultsService = module.get<AnalysisResultsService>(AnalysisResultsService);
        osvRepository = module.get<OSVRepository>(OSVRepository);
        nvdRepository = module.get<NVDRepository>(NVDRepository);
        osvReportGenerator = module.get<OSVReportGenerator>(OSVReportGenerator);
        nvdReportGenerator = module.get<NVDReportGenerator>(NVDReportGenerator);
        vulnerabilitiesUtilsService = module.get<VulnerabilitiesUtilsService>(
            VulnerabilitiesUtilsService
        );
        sbomUtilsService = module.get<SbomUtilsService>(SbomUtilsService);

        jest.clearAllMocks();

        // Set up default mock return values
        mockSbomUtilsService.getMergedSbomResults.mockResolvedValue({
            mergedSbom: mockSbomOutput
        });
        mockSbomUtilsService.getSbomResult.mockResolvedValue(mockSbomOutput);

        // Set up additional default mocks
        mockFriendsOfPhpRepository.getVuln.mockResolvedValue(null);
    });

    describe('getVulnerability', () => {
        it('should return vulnerability details using OSV report generator when no conflict', async () => {
            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue(mockVulnsOutput);
            mockSbomUtilsService.getMergedSbomResults.mockResolvedValue({
                mergedSbom: mockSbomOutput
            });
            mockOSVRepository.getVulnCVE.mockResolvedValue(mockOSVVuln);
            mockNVDRepository.getVuln.mockResolvedValue(mockNVDVuln);
            mockFriendsOfPhpRepository.getVuln.mockResolvedValue(null); // No PHP vulnerabilities
            mockOSVReportGenerator.genReport.mockResolvedValue(mockVulnerabilityDetails);

            const result = await service.getVulnerability(
                'org-123',
                'project-123',
                'analysis-123',
                mockUser,
                'CVE-2024-1234',
                'default'
            );

            expect(result).toEqual(mockVulnerabilityDetails);
            expect(analysisResultsService.checkAccess).toHaveBeenCalledWith(
                'org-123',
                'project-123',
                'analysis-123',
                mockUser
            );
            expect(vulnerabilitiesUtilsService.getVulnsResult).toHaveBeenCalledWith('analysis-123');
            expect(sbomUtilsService.getMergedSbomResults).toHaveBeenCalledWith('analysis-123');
            expect(osvRepository.getVulnCVE).toHaveBeenCalledWith('CVE-2024-1234');
            expect(nvdRepository.getVuln).toHaveBeenCalledWith('CVE-2024-1234');
            expect(osvReportGenerator.genReport).toHaveBeenCalledWith(
                expect.objectContaining({
                    ...mockVulnerability,
                    OSVMatch: expect.objectContaining({
                        Vulnerability: mockOSVVuln,
                        Dependency: null,
                        AffectedInfo: []
                    })
                }),
                'NPM',
                mockSbomOutput.workspaces.default.dependencies.package1['1.0.0'],
                mockOSVVuln,
                mockNVDVuln,
                undefined
            );
        });

        it('should use NVD report generator when conflict winner is NVD', async () => {
            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue(mockVulnsOutput);
            mockSbomUtilsService.getSbomResult.mockResolvedValue({
                ...mockSbomOutput,
                workspaces: {
                    default: {
                        dependencies: {
                            package2: {
                                '2.0.0': {
                                    name: 'package2',
                                    version: '2.0.0',
                                    license: 'Apache-2.0'
                                }
                            }
                        }
                    }
                }
            });
            mockOSVRepository.getVulnCVE.mockResolvedValue(mockOSVVuln);
            mockNVDRepository.getVuln.mockResolvedValue(mockNVDVuln);
            mockNVDReportGenerator.genReport.mockResolvedValue(mockVulnerabilityDetails);

            const result = await service.getVulnerability(
                'org-123',
                'project-123',
                'analysis-123',
                mockUser,
                'CVE-2024-5678',
                'default'
            );

            expect(result).toEqual(mockVulnerabilityDetails);
            expect(nvdReportGenerator.genReport).toHaveBeenCalled();
        });

        it('should use OSV report generator when conflict winner is OSV', async () => {
            const osvWinnerVulnerability = {
                ...mockVulnerabilityWithConflict,
                Conflict: { ConflictWinner: 'OSV' }
            };
            const vulnsOutputWithOSVWinner = {
                workspaces: {
                    default: {
                        Vulnerabilities: [osvWinnerVulnerability]
                    }
                }
            };

            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue(
                vulnsOutputWithOSVWinner
            );
            mockSbomUtilsService.getSbomResult.mockResolvedValue({
                ...mockSbomOutput,
                workspaces: {
                    default: {
                        dependencies: {
                            package2: {
                                '2.0.0': {
                                    name: 'package2',
                                    version: '2.0.0',
                                    license: 'Apache-2.0'
                                }
                            }
                        }
                    }
                }
            });
            mockOSVRepository.getVulnCVE.mockResolvedValue(mockOSVVuln);
            mockNVDRepository.getVuln.mockResolvedValue(mockNVDVuln);
            mockOSVReportGenerator.genReport.mockResolvedValue(mockVulnerabilityDetails);

            const result = await service.getVulnerability(
                'org-123',
                'project-123',
                'analysis-123',
                mockUser,
                'CVE-2024-5678',
                'default'
            );

            expect(result).toEqual(mockVulnerabilityDetails);
            expect(osvReportGenerator.genReport).toHaveBeenCalled();
        });

        it('should handle GHSA vulnerabilities', async () => {
            const ghsaVulnerability = {
                VulnerabilityId: 'GHSA-1234-5678-9abc',
                AffectedDependency: 'package1',
                AffectedVersion: '1.0.0',
                Conflict: null
            };
            const vulnsOutputWithGHSA = {
                workspaces: {
                    default: {
                        Vulnerabilities: [ghsaVulnerability]
                    }
                }
            };

            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue(vulnsOutputWithGHSA);
            mockSbomUtilsService.getMergedSbomResults.mockResolvedValue({
                mergedSbom: mockSbomOutput
            });
            mockOSVRepository.getVulnGHSA.mockResolvedValue(mockOSVVuln);
            mockNVDRepository.getVuln.mockResolvedValue(mockNVDVuln);
            mockOSVReportGenerator.genReport.mockResolvedValue(mockVulnerabilityDetails);

            const result = await service.getVulnerability(
                'org-123',
                'project-123',
                'analysis-123',
                mockUser,
                'GHSA-1234-5678-9abc',
                'default'
            );

            expect(result).toEqual(mockVulnerabilityDetails);
            expect(osvRepository.getVulnGHSA).toHaveBeenCalledWith('GHSA-1234-5678-9abc');
        });

        it('should throw EntityNotFound when both repositories fail', async () => {
            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue(mockVulnsOutput);
            mockSbomUtilsService.getSbomResult.mockResolvedValue(mockSbomOutput);
            mockOSVRepository.getVulnCVE.mockRejectedValue(new Error('OSV error'));
            mockNVDRepository.getVuln.mockRejectedValue(new Error('NVD error'));
            mockOSVReportGenerator.genReport.mockResolvedValue(mockVulnerabilityDetails);

            // Should throw EntityNotFound when no vulnerability data is available
            await expect(
                service.getVulnerability(
                    'org-123',
                    'project-123',
                    'analysis-123',
                    mockUser,
                    'CVE-2024-1234',
                    'default'
                )
            ).rejects.toThrow(EntityNotFound);
        });

        it('should throw UnknownWorkspace for invalid workspace', async () => {
            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue({
                workspaces: {}
            });

            await expect(
                service.getVulnerability(
                    'org-123',
                    'project-123',
                    'analysis-123',
                    mockUser,
                    'CVE-2024-1234',
                    'invalid-workspace'
                )
            ).rejects.toThrow(UnknownWorkspace);
        });

        it('should throw EntityNotFound for non-existent vulnerability', async () => {
            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue({
                workspaces: {
                    default: {
                        Vulnerabilities: []
                    }
                }
            });

            await expect(
                service.getVulnerability(
                    'org-123',
                    'project-123',
                    'analysis-123',
                    mockUser,
                    'CVE-9999-9999',
                    'default'
                )
            ).rejects.toThrow(EntityNotFound);
        });

        it('should throw EntityNotFound for non-existent dependency', async () => {
            const vulnWithMissingDep = {
                VulnerabilityId: 'CVE-2024-1234',
                AffectedDependency: 'non-existent-package',
                AffectedVersion: '1.0.0',
                Conflict: null
            };

            mockAnalysisResultsService.checkAccess.mockResolvedValue(undefined);
            mockVulnerabilitiesUtilsService.getVulnsResult.mockResolvedValue({
                workspaces: {
                    default: {
                        Vulnerabilities: [vulnWithMissingDep]
                    }
                }
            });
            mockSbomUtilsService.getSbomResult.mockResolvedValue(mockSbomOutput);

            await expect(
                service.getVulnerability(
                    'org-123',
                    'project-123',
                    'analysis-123',
                    mockUser,
                    'CVE-2024-1234',
                    'default'
                )
            ).rejects.toThrow(EntityNotFound);
        });

        it('should handle access check failure', async () => {
            const accessError = new Error('Access denied');
            mockAnalysisResultsService.checkAccess.mockRejectedValue(accessError);

            await expect(
                service.getVulnerability(
                    'org-123',
                    'project-123',
                    'analysis-123',
                    mockUser,
                    'CVE-2024-1234',
                    'default'
                )
            ).rejects.toThrow('Access denied');

            expect(vulnerabilitiesUtilsService.getVulnsResult).not.toHaveBeenCalled();
        });
    });
});
