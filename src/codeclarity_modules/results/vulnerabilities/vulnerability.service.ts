import { Injectable } from '@nestjs/common';
import { AnalysisResultsService } from '../results.service';
import { AuthenticatedUser } from 'src/base_modules/auth/auth.types';
import { OSVRepository } from 'src/codeclarity_modules/knowledge/osv/osv.repository';
import { NVDRepository } from 'src/codeclarity_modules/knowledge/nvd/nvd.repository';
import { FriendsOfPhpRepository } from 'src/codeclarity_modules/knowledge/friendsofphp/friendsofphp.repository';
import { NVDReportGenerator, OSVReportGenerator } from './services/reportGenerator';
import { EntityNotFound, UnknownWorkspace } from 'src/types/error.types';
import { VulnerabilityDetails } from 'src/codeclarity_modules/results/vulnerabilities/vulnerabilities2.types';
import { Vulnerability } from 'src/codeclarity_modules/results/vulnerabilities/vulnerabilities.types';
import { Output as VulnsOutput } from 'src/codeclarity_modules/results/vulnerabilities/vulnerabilities.types';
import { PatchInfo } from 'src/codeclarity_modules/results/patching/patching.types';
import { Dependency } from 'src/codeclarity_modules/results/sbom/sbom.types';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { Result } from 'src/codeclarity_modules/results/result.entity';
import { VulnerabilitiesUtilsService } from './utils/utils.service';
import { SbomUtilsService } from '../sbom/utils/utils';
import { PatchingUtilsService } from '../patching/utils/utils';

@Injectable()
export class VulnerabilityService {
    constructor(
        private readonly analysisResultsService: AnalysisResultsService,
        private readonly osvRepository: OSVRepository,
        private readonly nvdRepository: NVDRepository,
        private readonly friendsOfPhpRepository: FriendsOfPhpRepository,
        private readonly osvReportGenerator: OSVReportGenerator,
        private readonly nvdReportGenerator: NVDReportGenerator,
        private readonly vulnerabilitiesUtilsService: VulnerabilitiesUtilsService,
        private readonly patchingUtilsService: PatchingUtilsService,
        private readonly sbomUtilsService: SbomUtilsService,
        @InjectRepository(Result, 'codeclarity')
        private resultRepository: Repository<Result>
    ) {}

    async getVulnerability(
        orgId: string,
        projectId: string,
        analysisId: string,
        user: AuthenticatedUser,
        vulnerabilityId: string,
        workspace: string
    ): Promise<VulnerabilityDetails> {
        // Check if the user is allowed to view this analysis result
        await this.analysisResultsService.checkAccess(orgId, projectId, analysisId, user);

        const vulnMatch = await this.getVuln(analysisId, workspace, vulnerabilityId);
        
        // Try to get dependency data, but handle cases where it's not found
        let dependencyData;
        try {
            dependencyData = await this.getDependency(
                analysisId,
                workspace,
                vulnMatch.AffectedDependency,
                vulnMatch.AffectedVersion
            );
        } catch (error) {
            console.warn(`Dependency not found in SBOM: ${vulnMatch.AffectedDependency}@${vulnMatch.AffectedVersion}`, error.message);
            dependencyData = undefined;
        }
        const packageManager = await this.getPackageManager(analysisId);

        let nvdVuln;
        let osvVuln;
        let friendsOfPhpVuln;

        try {
            nvdVuln = await this.nvdRepository.getVuln(vulnerabilityId);
        } catch (error) {
            console.error(error);
        }

        try {
            if (vulnerabilityId.startsWith('CVE')) {
                osvVuln = await this.osvRepository.getVulnCVE(vulnerabilityId);
            } else {
                osvVuln = await this.osvRepository.getVulnGHSA(vulnerabilityId);
            }
            console.log('üîç OSV data fetched:', {
                vulnId: vulnerabilityId,
                osvFound: !!osvVuln,
                osvId: osvVuln?.osv_id,
                osvHasAffected: osvVuln?.affected?.length > 0
            });
        } catch (error) {
            console.error(error);
        }

        try {
            if (vulnerabilityId.startsWith('CVE')) {
                friendsOfPhpVuln = await this.friendsOfPhpRepository.getVuln(vulnerabilityId);
            }
        } catch (error) {
            console.error(error);
        }

        // If neither NVD nor OSV data found, the vulnerability doesn't exist
        if (!nvdVuln && !osvVuln) {
            throw new EntityNotFound();
        }

        // In case there was a conflict we generate the report information from the report that was considered "correct"
        if (vulnMatch.Conflict && vulnMatch.Conflict.ConflictWinner == 'NVD') {
            // The report from the NVD was considered correct
            return await this.nvdReportGenerator.genReport(
                vulnMatch,
                packageManager,
                dependencyData,
                osvVuln,
                nvdVuln,
                friendsOfPhpVuln || undefined
            );
        } else if (vulnMatch.Conflict && vulnMatch.Conflict.ConflictWinner == 'OSV') {
            // The report from the OSV was considered correct
            return await this.osvReportGenerator.genReport(
                vulnMatch,
                packageManager,
                dependencyData,
                osvVuln,
                nvdVuln,
                friendsOfPhpVuln || undefined
            );
        } else {
            // In case there was no conflict, use the appropriate report generator based on available data
            // If OSV data exists, prefer it; otherwise use NVD
            console.log('üîç Selecting report generator:', {
                hasOSV: !!osvVuln,
                hasValidOSV: !!(osvVuln && osvVuln.osv_id),
                hasNVD: !!nvdVuln,
                conflict: vulnMatch.Conflict
            });
            
            // Check if OSV data actually exists (not just an empty object)
            const hasValidOsvData = osvVuln && osvVuln.osv_id;
            
            // If we have OSV data but vulnMatch doesn't have OSVMatch, add it
            // This handles cases where the vulnerability was only found via NVD during analysis
            // but OSV data exists in the database
            if (hasValidOsvData && !vulnMatch.OSVMatch) {
                console.log('üîç Adding missing OSVMatch to vulnerability data');
                vulnMatch.OSVMatch = {
                    Vulnerability: osvVuln,
                    Dependency: null,
                    AffectedInfo: vulnMatch.NVDMatch?.AffectedInfo || [],
                    Vulnerable: true,
                    VulnerableEvidenceType: null,
                    VulnerableEvidenceRange: null,
                    VulnerableEvidenceExact: null,
                    VulnerableEvidenceUniversal: null,
                    ConflictFlag: null,
                    Severity: null,
                    SeverityType: null
                };
            }
            
            if (hasValidOsvData) {
                console.log('üîç Using OSV report generator');
                return await this.osvReportGenerator.genReport(
                    vulnMatch,
                    packageManager,
                    dependencyData,
                    osvVuln,
                    nvdVuln,
                    friendsOfPhpVuln || undefined
                );
            } else if (nvdVuln) {
                console.log('üîç Using NVD report generator (no OSV data)');
                return await this.nvdReportGenerator.genReport(
                    vulnMatch,
                    packageManager,
                    dependencyData,
                    osvVuln,
                    nvdVuln,
                    friendsOfPhpVuln || undefined
                );
            } else {
                // This shouldn't happen as we check for both being null earlier
                throw new EntityNotFound();
            }
        }
    }

    private async getPackageManager(analysis_id: string): Promise<string> {
        const { mergedSbom } = await this.sbomUtilsService.getMergedSbomResults(analysis_id);
        return mergedSbom.analysis_info.package_manager;
    }

    private async getDependency(
        analysis_id: string,
        workspace: string,
        affected_dependency_name: string,
        affected_dependency_version: string
    ): Promise<Dependency | undefined> {
        // Get merged SBOM results from all supported plugins
        const { mergedSbom } = await this.sbomUtilsService.getMergedSbomResults(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in mergedSbom.workspaces)) {
            throw new UnknownWorkspace();
        }

        // Check if this is a framework vulnerability (starts with 'framework-')
        if (affected_dependency_name.startsWith('framework-')) {
            // Framework vulnerabilities don't have corresponding SBOM entries
            // Return undefined to indicate no dependency data is available
            console.log('üîç Framework dependency detected:', affected_dependency_name, 'version:', affected_dependency_version);
            return undefined;
        }

        if (affected_dependency_name in mergedSbom.workspaces[workspace].dependencies) {
            return mergedSbom.workspaces[workspace].dependencies[affected_dependency_name][
                affected_dependency_version
            ];
        }

        throw new EntityNotFound();
    }

    private async getPatch(
        analysis_id: string,
        workspace: string,
        vuln_id: string,
        affected_dependency_name: string,
        affected_dependency_version: string
    ): Promise<PatchInfo> {
        const patchInfo = await this.patchingUtilsService.getPatchingResult(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in patchInfo.workspaces)) {
            throw new UnknownWorkspace();
        }

        if (
            affected_dependency_name + '@' + affected_dependency_version in
            patchInfo.workspaces[workspace].dev_patches
        ) {
            return patchInfo.workspaces[workspace].dev_patches[
                affected_dependency_name + '@' + affected_dependency_version
            ];
        }

        throw new EntityNotFound();
    }

    private async getVuln(
        analysis_id: string,
        workspace: string,
        vulnerability_id: string
    ): Promise<Vulnerability> {
        const vulns: VulnsOutput =
            await this.vulnerabilitiesUtilsService.getVulnsResult(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in vulns.workspaces)) {
            throw new UnknownWorkspace();
        }

        const vulnerabilities = vulns.workspaces[workspace].Vulnerabilities;
        
        // Handle both individual vulnerabilities and merged vulnerabilities
        for (const vuln of vulnerabilities) {
            if (vuln.VulnerabilityId == vulnerability_id) {
                return vuln;
            }
            
            // Check if this is a merged vulnerability (VulnerabilityMerged)
            if ((vuln as any).Vulnerability == vulnerability_id) {
                // Convert merged vulnerability to individual format by taking the first affected dependency
                const merged = vuln as any; // VulnerabilityMerged type
                console.log('üîç Found merged vulnerability:', {
                    vulnId: vulnerability_id,
                    affected: merged.Affected,
                    affectedCount: merged.Affected?.length
                });
                
                if (merged.Affected && merged.Affected.length > 0) {
                    const firstAffected = merged.Affected[0];
                    console.log('üîç First affected in merged vuln:', {
                        affectedDep: firstAffected.AffectedDependency,
                        affectedVersion: firstAffected.AffectedVersion,
                        depName: firstAffected.DependencyName,
                        depVersion: firstAffected.DependencyVersion
                    });
                    
                    return {
                        Id: firstAffected.Id || '',
                        Sources: firstAffected.Sources || [],
                        AffectedDependency: firstAffected.AffectedDependency || firstAffected.DependencyName,
                        AffectedVersion: firstAffected.AffectedVersion || firstAffected.DependencyVersion,
                        VulnerabilityId: firstAffected.VulnerabilityId || vulnerability_id,
                        Severity: firstAffected.Severity,
                        Weaknesses: firstAffected.Weaknesses,
                        OSVMatch: firstAffected.OSVMatch,
                        NVDMatch: firstAffected.NVDMatch,
                        Conflict: firstAffected.Conflict
                    } as Vulnerability;
                }
            }
        }

        throw new EntityNotFound();
    }
}
