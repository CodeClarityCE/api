import { Injectable } from '@nestjs/common';
import { AnalysisResultsService } from '../results.service';
import { AuthenticatedUser } from 'src/types/auth/types';
import { OSVRepository } from 'src/codeclarity_modules/knowledge/osv/osv.repository';
import { NVDRepository } from 'src/codeclarity_modules/knowledge/nvd/nvd.repository';
import { NVDReportGenerator, OSVReportGenerator } from './services/reportGenerator';
import { EntityNotFound, UnknownWorkspace } from 'src/types/errors/types';
import { getPatchingResult } from '../patching/utils/utils';
import { getSbomResult } from '../sbom/utils/utils';
import { getVulnsResult } from './utils/utils';
import { VulnerabilityDetails } from 'src/types/entities/frontend/Vulnerability';
import { Vulnerability } from 'src/types/entities/services/Vulnerabilities';
import { Output as VulnsOutput } from 'src/types/entities/services/Vulnerabilities';
import { PatchInfo } from 'src/types/entities/services/Patching';
import { Dependency } from 'src/types/entities/services/Sbom';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { Result } from 'src/entity/codeclarity/Result';

@Injectable()
export class FindingService {
    constructor(
        private readonly analysisResultsService: AnalysisResultsService,
        private readonly osvRepository: OSVRepository,
        private readonly nvdRepository: NVDRepository,
        private readonly osvReportGenerator: OSVReportGenerator,
        private readonly nvdReportGenerator: NVDReportGenerator,
        @InjectRepository(Result, 'codeclarity')
        private resultRepository: Repository<Result>
    ) {}

    async getVulnerability(
        orgId: string,
        projectId: string,
        analysisId: string,
        user: AuthenticatedUser,
        vulnerabilityId: string,
        workspace: string
    ): Promise<VulnerabilityDetails> {
        // Check if the user is allowed to view this analysis result
        await this.analysisResultsService.checkAccess(orgId, projectId, analysisId, user);

        const vulnMatch: Vulnerability = await this.getVuln(analysisId, workspace, vulnerabilityId);
        vulnerabilityId = vulnMatch.VulnerabilityId;

        // const patchesData: PatchInfo = await this.getPatch(
        //     analysisId,
        //     workspace,
        //     vulnMatch.VulnerabilityId,
        //     vulnMatch.AffectedDependency,
        //     vulnMatch.AffectedVersion
        // );
        const dependencyData = await this.getDependency(
            analysisId,
            workspace,
            vulnMatch.AffectedDependency,
            vulnMatch.AffectedVersion
        );
        const packageManger = await this.getPackageManager(analysisId);

        let nvdVuln;
        let osvVuln;

        try {
            nvdVuln = await this.nvdRepository.getVuln(vulnerabilityId);
        } catch (error) {
            /* empty */
        }

        try {
            if (vulnerabilityId.startsWith('CVE')) {
                osvVuln = await this.osvRepository.getVulnCVE(vulnerabilityId);
            } else {
                osvVuln = await this.osvRepository.getVulnGHSA(vulnerabilityId);
            }
        } catch (error) {
            /* empty */
        }

        // In case there was a conflict we generate the report information from thereport that was considered "correct"
        if (vulnMatch.NVDMatch.AffectedInfo) {
            // The report from the NVD was considered correct
            return await this.nvdReportGenerator.genReport(
                vulnMatch,
                packageManger,
                dependencyData,
                osvVuln,
                nvdVuln
            );
        } else if (vulnMatch.OSVMatch.AffectedInfo) {
            // The report from the OSV was considered correct
            return await this.osvReportGenerator.genReport(
                vulnMatch,
                packageManger,
                dependencyData,
                osvVuln,
                nvdVuln
            );
        } else {
            // In case there was no conflict we generate the report information from the OSV database
            return await this.osvReportGenerator.genReport(
                vulnMatch,
                packageManger,
                dependencyData,
                osvVuln,
                nvdVuln
            );
        }
    }

    private async getPackageManager(analysis_id: string): Promise<string> {
        const sbomInfo = await getSbomResult(analysis_id, this.resultRepository);
        return sbomInfo.analysis_info.package_manager;
    }

    private async getDependency(
        analysis_id: string,
        workspace: string,
        affected_dependency_name: string,
        affected_dependency_version: string
    ): Promise<Dependency> {
        const sbomInfo = await getSbomResult(analysis_id, this.resultRepository);

        // Validate that the workspace exists
        if (!(workspace in sbomInfo.workspaces)) {
            throw new UnknownWorkspace();
        }

        if (affected_dependency_name in sbomInfo.workspaces[workspace].dependencies) {
            return sbomInfo.workspaces[workspace].dependencies[affected_dependency_name][
                affected_dependency_version
            ];
        }

        throw new EntityNotFound();
    }

    private async getPatch(
        analysis_id: string,
        workspace: string,
        vuln_id: string,
        affected_dependency_name: string,
        affected_dependency_version: string
    ): Promise<PatchInfo> {
        const patchInfo = await getPatchingResult(analysis_id, this.resultRepository);

        // Validate that the workspace exists
        if (!(workspace in patchInfo.workspaces)) {
            throw new UnknownWorkspace();
        }

        if (
            affected_dependency_name + '@' + affected_dependency_version in
            patchInfo.workspaces[workspace].dev_patches
        ) {
            return patchInfo.workspaces[workspace].dev_patches[
                affected_dependency_name + '@' + affected_dependency_version
            ];
        }

        throw new EntityNotFound();
    }

    private async getVuln(
        analysis_id: string,
        workspace: string,
        vulnerability_id: string
    ): Promise<Vulnerability> {
        const vulns: VulnsOutput = await getVulnsResult(analysis_id, this.resultRepository);

        // Validate that the workspace exists
        if (!(workspace in vulns.workspaces)) {
            throw new UnknownWorkspace();
        }

        const vulnerabilities = vulns.workspaces[workspace].Vulnerabilities;
        for (const vuln of vulnerabilities) {
            if (vuln.VulnerabilityId == vulnerability_id) {
                return vuln;
            }
        }

        throw new EntityNotFound();
    }
}
