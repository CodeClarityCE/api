import { Injectable } from '@nestjs/common';
import { AuthenticatedUser } from 'src/base_modules/auth/auth.types';
import { FriendsOfPhpRepository } from 'src/codeclarity_modules/knowledge/friendsofphp/friendsofphp.repository';
import { NVDRepository } from 'src/codeclarity_modules/knowledge/nvd/nvd.repository';
import { OSVRepository } from 'src/codeclarity_modules/knowledge/osv/osv.repository';
import { Dependency } from 'src/codeclarity_modules/results/sbom/sbom.types';
import {
    Vulnerability,
    VulnerabilityMerged,
    Output as VulnsOutput,
    VulnerabilityDetailsReport
} from 'src/codeclarity_modules/results/vulnerabilities/vulnerabilities.types';
import { EntityNotFound, UnknownWorkspace } from 'src/types/error.types';
import { AnalysisResultsService } from '../results.service';
import { SbomUtilsService } from '../sbom/utils/utils';
import { NVDReportGenerator, OSVReportGenerator } from './services/reportGenerator';
import { VulnerabilitiesUtilsService } from './utils/utils.service';

@Injectable()
export class VulnerabilityService {
    constructor(
        private readonly analysisResultsService: AnalysisResultsService,
        private readonly osvRepository: OSVRepository,
        private readonly nvdRepository: NVDRepository,
        private readonly friendsOfPhpRepository: FriendsOfPhpRepository,
        private readonly osvReportGenerator: OSVReportGenerator,
        private readonly nvdReportGenerator: NVDReportGenerator,
        private readonly vulnerabilitiesUtilsService: VulnerabilitiesUtilsService,
        private readonly sbomUtilsService: SbomUtilsService
    ) {}

    async getVulnerability(
        orgId: string,
        projectId: string,
        analysisId: string,
        user: AuthenticatedUser,
        vulnerabilityId: string,
        workspace: string
    ): Promise<VulnerabilityDetailsReport> {
        // Check if the user is allowed to view this analysis result
        await this.analysisResultsService.checkAccess(orgId, projectId, analysisId, user);

        const vulnMatch = await this.getVuln(analysisId, workspace, vulnerabilityId);

        // Try to get dependency data, but handle cases where it's not found
        let dependencyData;
        try {
            dependencyData = await this.getDependency(
                analysisId,
                workspace,
                vulnMatch.AffectedDependency,
                vulnMatch.AffectedVersion
            );
        } catch (error) {
            console.warn(
                `Dependency not found in SBOM: ${vulnMatch.AffectedDependency}@${vulnMatch.AffectedVersion}`,
                (error as Error).message
            );
            dependencyData = undefined;
        }
        const packageManager = await this.getPackageManager(analysisId);

        let nvdVuln;
        let osvVuln;
        let friendsOfPhpVuln;

        try {
            nvdVuln = await this.nvdRepository.getVuln(vulnerabilityId);
        } catch (error) {
            console.error(error as Error);
        }

        try {
            if (vulnerabilityId.startsWith('CVE')) {
                osvVuln = await this.osvRepository.getVulnCVE(vulnerabilityId);
            } else {
                osvVuln = await this.osvRepository.getVulnGHSA(vulnerabilityId);
            }
            console.error('üîç OSV data fetched:', {
                vulnId: vulnerabilityId,
                osvFound: !!osvVuln,
                osvId: osvVuln?.osv_id,
                osvHasAffected: Array.isArray(osvVuln?.affected) && osvVuln.affected.length > 0
            });
        } catch (error) {
            console.error(error as Error);
        }

        try {
            if (vulnerabilityId.startsWith('CVE')) {
                friendsOfPhpVuln = await this.friendsOfPhpRepository.getVuln(vulnerabilityId);
            }
        } catch (error) {
            console.error(error);
        }

        // If neither NVD nor OSV data found, the vulnerability doesn't exist
        if (!nvdVuln && !osvVuln) {
            throw new EntityNotFound();
        }

        // In case there was a conflict we generate the report information from the report that was considered "correct"
        if (vulnMatch.Conflict?.ConflictWinner === 'NVD') {
            // The report from the NVD was considered correct
            return await this.nvdReportGenerator.genReport(
                vulnMatch,
                packageManager,
                dependencyData,
                osvVuln,
                nvdVuln,
                friendsOfPhpVuln ?? undefined
            );
        } else if (vulnMatch.Conflict?.ConflictWinner === 'OSV') {
            // The report from the OSV was considered correct
            return await this.osvReportGenerator.genReport(
                vulnMatch,
                packageManager,
                dependencyData,
                osvVuln,
                nvdVuln,
                friendsOfPhpVuln ?? undefined
            );
        } else {
            // In case there was no conflict, use the appropriate report generator based on available data
            // If OSV data exists, prefer it; otherwise use NVD
            console.error('üîç Selecting report generator:', {
                hasOSV: !!osvVuln,
                hasValidOSV: !!osvVuln?.osv_id,
                hasNVD: !!nvdVuln,
                conflict: vulnMatch.Conflict
            });

            // Check if OSV data actually exists (not just an empty object)
            const hasValidOsvData = osvVuln?.osv_id;

            // If we have OSV data but vulnMatch doesn't have OSVMatch, add it
            // This handles cases where the vulnerability was only found via NVD during analysis
            // but OSV data exists in the database
            if (hasValidOsvData && !vulnMatch.OSVMatch) {
                console.error('üîç Adding missing OSVMatch to vulnerability data');
                vulnMatch.OSVMatch = {
                    Vulnerability: osvVuln ?? null,
                    Dependency: null,
                    AffectedInfo: vulnMatch.NVDMatch?.AffectedInfo || [],
                    Vulnerable: true,
                    VulnerableEvidenceType: null,
                    VulnerableEvidenceRange: null,
                    VulnerableEvidenceExact: null,
                    VulnerableEvidenceUniversal: null,
                    ConflictFlag: null,
                    Severity: null,
                    SeverityType: null
                };
            }

            if (hasValidOsvData) {
                console.error('üîç Using OSV report generator');
                return await this.osvReportGenerator.genReport(
                    vulnMatch,
                    packageManager,
                    dependencyData,
                    osvVuln,
                    nvdVuln,
                    friendsOfPhpVuln ?? undefined
                );
            } else if (nvdVuln) {
                console.error('üîç Using NVD report generator (no OSV data)');
                return await this.nvdReportGenerator.genReport(
                    vulnMatch,
                    packageManager,
                    dependencyData,
                    osvVuln,
                    nvdVuln,
                    friendsOfPhpVuln ?? undefined
                );
            } else {
                // This shouldn't happen as we check for both being null earlier
                throw new EntityNotFound();
            }
        }
    }

    private async getPackageManager(analysis_id: string): Promise<string> {
        const { mergedSbom } = await this.sbomUtilsService.getMergedSbomResults(analysis_id);
        return mergedSbom.analysis_info.package_manager;
    }

    private async getDependency(
        analysis_id: string,
        workspace: string,
        affected_dependency_name: string,
        affected_dependency_version: string
    ): Promise<Dependency | undefined> {
        // Get merged SBOM results from all supported plugins
        const { mergedSbom } = await this.sbomUtilsService.getMergedSbomResults(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in mergedSbom.workspaces)) {
            throw new UnknownWorkspace();
        }

        // Check if this is a framework vulnerability (starts with 'framework-')
        if (affected_dependency_name.startsWith('framework-')) {
            // Framework vulnerabilities don't have corresponding SBOM entries
            // Return undefined to indicate no dependency data is available
            console.error(
                'üîç Framework dependency detected:',
                affected_dependency_name,
                'version:',
                affected_dependency_version
            );
            return undefined;
        }

        if (affected_dependency_name in mergedSbom.workspaces[workspace]!.dependencies) {
            return mergedSbom.workspaces[workspace]!.dependencies[affected_dependency_name]![
                affected_dependency_version
            ];
        }

        throw new EntityNotFound();
    }

    private async getVuln(
        analysis_id: string,
        workspace: string,
        vulnerability_id: string
    ): Promise<Vulnerability> {
        const vulns: VulnsOutput =
            await this.vulnerabilitiesUtilsService.getVulnsResult(analysis_id);

        // Validate that the workspace exists
        if (!(workspace in vulns.workspaces)) {
            throw new UnknownWorkspace();
        }

        const vulnerabilities = vulns.workspaces[workspace]!.Vulnerabilities;

        // Handle both individual vulnerabilities and merged vulnerabilities
        for (const vuln of vulnerabilities) {
            if (vuln.VulnerabilityId === vulnerability_id) {
                return vuln;
            }

            // Check if this is a merged vulnerability (VulnerabilityMerged)
            // Type guard: VulnerabilityMerged has 'Vulnerability' property, regular Vulnerability has 'VulnerabilityId'
            const merged = vuln as Vulnerability | VulnerabilityMerged;
            if ('Vulnerability' in merged && merged.Vulnerability === vulnerability_id) {
                // Convert merged vulnerability to individual format by taking the first affected dependency
                console.error('üîç Found merged vulnerability:', {
                    vulnId: vulnerability_id,
                    affected: merged.Affected,
                    affectedCount: merged.Affected?.length
                });

                if (merged.Affected && merged.Affected.length > 0) {
                    const firstAffected = merged.Affected[0];
                    if (firstAffected) {
                        console.error('üîç First affected in merged vuln:', {
                            affectedDep: firstAffected.AffectedDependency,
                            affectedVersion: firstAffected.AffectedVersion,
                            vulnId: firstAffected.VulnerabilityId
                        });

                        return {
                            Id: merged.Id,
                            Sources: firstAffected.Sources,
                            AffectedDependency: firstAffected.AffectedDependency,
                            AffectedVersion: firstAffected.AffectedVersion,
                            VulnerabilityId: firstAffected.VulnerabilityId,
                            Severity: firstAffected.Severity,
                            Weaknesses: firstAffected.Weaknesses,
                            OSVMatch: firstAffected.OSVMatch,
                            NVDMatch: firstAffected.NVDMatch,
                            Conflict: firstAffected.Conflict
                        } as Vulnerability;
                    }
                }
            }
        }

        throw new EntityNotFound();
    }
}
